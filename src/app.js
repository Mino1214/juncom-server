// app.js
import express from "express";
import cors from "cors";
import redis from "./redis.js";
import pg from "pg";
import dotenv from "dotenv";

// ÌôòÍ≤ΩÎ≥ÄÏàò Î°úÎìú
dotenv.config();

const app = express();
const { Pool } = pg;

// PostgreSQL Ïó∞Í≤∞
const pool = new Pool({
    host: process.env.DB_HOST || 'jimo.world',
    port: parseInt(process.env.DB_PORT || '5432'),
    database: process.env.DB_NAME || 'postgres',
    user: process.env.DB_USER || 'postgres',
    password: process.env.DB_PASSWORD || '1107',
    // ÏõêÍ≤© ÏÑúÎ≤Ñ Ïó∞Í≤∞Ïãú SSL ÏÑ§Ï†ï
    ssl: process.env.DB_HOST !== 'localhost' ? {
        rejectUnauthorized: false
    } : false
});

console.log('üìä DB Config:', {
    host: process.env.DB_HOST || 'localhost',
    port: process.env.DB_PORT || '5432',
    database: process.env.DB_NAME || 'employee_mall',
    user: process.env.DB_USER || 'postgres',
    ssl: process.env.DB_HOST !== 'localhost' ? 'enabled' : 'disabled'
});

// ÎØ∏Îì§Ïõ®Ïñ¥
app.use(express.json());
app.use(cors());

// Í∏∞Î≥∏ ÌÖåÏä§Ìä∏
app.get("/", (req, res) => {
    res.send("Node + Redis + PostgreSQL ÏÑúÎ≤Ñ Ïã§Ìñâ Ï§ë üöÄ");
});

// Redis Ïπ¥Ïö¥ÌÑ∞ ÌÖåÏä§Ìä∏
app.get("/count", async (req, res) => {
    const count = await redis.incr("visits");
    res.send(`ÌòÑÏû¨ Î∞©Î¨∏Ïûê Ïàò: ${count}`);
});

// ============================================
// Ìó¨Ìçº Ìï®Ïàò
// ============================================

// Redis Ï∫êÏãúÏóêÏÑú ÏÇ¨Ïö©Ïûê Ï°∞Ìöå
async function getUserFromCache(employeeId) {
    const cacheKey = `user:${employeeId}`;
    const cached = await redis.get(cacheKey);
    if (cached) {
        return JSON.parse(cached);
    }
    return null;
}

// Redis Ï∫êÏãúÏóê ÏÇ¨Ïö©Ïûê Ï†ÄÏû• (TTL: 1ÏãúÍ∞Ñ)
// Redis Ï∫êÏãúÏóê ÏÇ¨Ïö©Ïûê Ï†ÄÏû• (TTL: 1ÏãúÍ∞Ñ)
async function setUserCache(employeeId, userData) {
    const cacheKey = `user:${employeeId}`;
    await redis.set(cacheKey, JSON.stringify(userData), 'EX', 3600);
}

// Redis Ï∫êÏãú Î¨¥Ìö®Ìôî
async function invalidateUserCache(employeeId) {
    const cacheKey = `user:${employeeId}`;
    await redis.del(cacheKey);
}

// ============================================
// Ïù∏Ï¶ù API
// ============================================

// 1. ÏùºÎ∞ò Î°úÍ∑∏Ïù∏ (ÏÇ¨Î≤à/ÎπÑÎ∞ÄÎ≤àÌò∏)
app.post("/api/auth/login", async (req, res) => {
    const client = await pool.connect();

    try {
        const { employeeId, password } = req.body;

        if (!employeeId || !password) {
            return res.status(400).json({
                message: "ÏÇ¨Î≤àÍ≥º ÎπÑÎ∞ÄÎ≤àÌò∏Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî."
            });
        }

        // 1. Redis Ï∫êÏãú ÌôïÏù∏
        let user = await getUserFromCache(employeeId);

        // 2. Ï∫êÏãúÏóê ÏóÜÏúºÎ©¥ DB Ï°∞Ìöå
        if (!user) {
            const result = await client.query(
                'SELECT * FROM users WHERE employee_id = $1',
                [employeeId]
            );

            if (result.rows.length === 0) {
                return res.status(404).json({
                    message: "Îì±Î°ùÎêòÏßÄ ÏïäÏùÄ ÏÇ¨Î≤àÏûÖÎãàÎã§."
                });
            }

            user = result.rows[0];

            // RedisÏóê Ï∫êÏã±
            await setUserCache(employeeId, user);
        }

        // ÎπÑÎ∞ÄÎ≤àÌò∏ ÌôïÏù∏ (Ïã§Ï†úÎ°úÎäî bcrypt ÏÇ¨Ïö©)
        if (user.password !== password) {
            return res.status(401).json({
                message: "ÎπÑÎ∞ÄÎ≤àÌò∏Í∞Ä ÏùºÏπòÌïòÏßÄ ÏïäÏäµÎãàÎã§."
            });
        }

        // Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µ
        res.json({
            name: user.name,
            employeeId: user.employee_id,
            email: user.email
        });

    } catch (error) {
        console.error("Login error:", error);
        res.status(500).json({
            message: "ÏÑúÎ≤Ñ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§."
        });
    } finally {
        client.release();
    }
});

// 2. Ïπ¥Ïπ¥Ïò§ Î°úÍ∑∏Ïù∏
app.post("/api/auth/kakao", async (req, res) => {
    const client = await pool.connect();

    try {
        const { kakaoId, accessToken, name, email } = req.body;

        if (!kakaoId) {
            return res.status(400).json({
                message: "Ïπ¥Ïπ¥Ïò§ IDÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§."
            });
        }

        // 1. RedisÏóêÏÑú Ïπ¥Ïπ¥Ïò§ ID Îß§Ìïë ÌôïÏù∏
        const cachedEmployeeId = await redis.get(`kakao:${kakaoId}`);

        let user;
        if (cachedEmployeeId) {
            // Ï∫êÏãúÏóêÏÑú ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Ï°∞Ìöå
            user = await getUserFromCache(cachedEmployeeId);

            // Ï∫êÏãúÏóê ÏóÜÏúºÎ©¥ DB Ï°∞Ìöå
            if (!user) {
                const result = await client.query(
                    'SELECT * FROM public.users WHERE employee_id = $1',
                    [cachedEmployeeId]
                );
                user = result.rows[0];
                if (user) {
                    await setUserCache(user.employee_id, user);
                }
            }
        } else {
            // 2. DBÏóêÏÑú Ïπ¥Ïπ¥Ïò§ IDÎ°ú ÏÇ¨Ïö©Ïûê Í≤ÄÏÉâ
            const result = await client.query(
                'SELECT * FROM public.users WHERE kakao_id = $1',
                [kakaoId]
            );

            if (result.rows.length > 0) {
                user = result.rows[0];
                // RedisÏóê Îß§Ìïë Î∞è Ï∫êÏã±
                await redis.set(`kakao:${kakaoId}`, user.employee_id);
                await setUserCache(user.employee_id, user);
            }
        }

        if (user) {
            // Í∏∞Ï°¥ ÌöåÏõê
            res.json({
                isRegistered: true,
                name: user.name,
                employeeId: user.employee_id,
                email: user.email
            });
        } else {
            // Ïã†Í∑ú ÌöåÏõê
            res.json({
                isRegistered: false,
                kakaoName: name,
                kakaoEmail: email
            });
        }

    } catch (error) {
        console.error("Kakao login error:", error);
        res.status(500).json({
            message: "Ïπ¥Ïπ¥Ïò§ Î°úÍ∑∏Ïù∏ Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§."
        });
    } finally {
        client.release();
    }
});

// 3. ÌöåÏõêÍ∞ÄÏûÖ
app.post("/api/auth/signup", async (req, res) => {
    const client = await pool.connect();

    try {
        const { employeeId, password, name, email, phone, address, kakaoId, marketingAgreed } = req.body;

        if (!employeeId || !name) {
            return res.status(400).json({
                message: "ÌïÑÏàò Ï†ïÎ≥¥Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî."
            });
        }

        // Ìä∏ÎûúÏû≠ÏÖò ÏãúÏûë
        await client.query('BEGIN');

        // 1. Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî ÏÇ¨Î≤àÏù∏ÏßÄ ÌôïÏù∏
        const existCheck = await client.query(
            'SELECT employee_id FROM users WHERE employee_id = $1',
            [employeeId]
        );

        if (existCheck.rows.length > 0) {
            await client.query('ROLLBACK');
            return res.status(409).json({
                message: "Ïù¥ÎØ∏ Îì±Î°ùÎêú ÏÇ¨Î≤àÏûÖÎãàÎã§."
            });
        }

        // 2. DBÏóê ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Ï†ÄÏû•
        const insertResult = await client.query(
            `INSERT INTO users (employee_id, password, name, email, phone, address, kakao_id, marketing_agreed, created_at)
             VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW())
             RETURNING *`,
            [employeeId, password || '', name, email || '', phone || '', address || '', kakaoId || null, marketingAgreed || false]
        );

        const newUser = insertResult.rows[0];

        // 3. Ïπ¥Ïπ¥Ïò§ ID Îß§Ìïë Ï†ÄÏû• (Redis)
        if (kakaoId) {
            await redis.set(`kakao:${kakaoId}`, employeeId);
        }

        // 4. ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Ï∫êÏã± (Redis)
        await setUserCache(employeeId, newUser);

        // Ìä∏ÎûúÏû≠ÏÖò Ïª§Î∞ã
        await client.query('COMMIT');

        res.status(201).json({
            message: "ÌöåÏõêÍ∞ÄÏûÖÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§.",
            name,
            employeeId
        });

    } catch (error) {
        await client.query('ROLLBACK');
        console.error("Signup error:", error);
        res.status(500).json({
            message: "ÌöåÏõêÍ∞ÄÏûÖ Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§."
        });
    } finally {
        client.release();
    }
});

// 4. ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Ï°∞Ìöå
app.get("/api/user/:employeeId", async (req, res) => {
    const client = await pool.connect();

    try {
        const { employeeId } = req.params;

        // 1. Redis Ï∫êÏãú ÌôïÏù∏
        let user = await getUserFromCache(employeeId);

        // 2. Ï∫êÏãúÏóê ÏóÜÏúºÎ©¥ DB Ï°∞Ìöå
        if (!user) {
            const result = await client.query(
                'SELECT * FROM users WHERE employee_id = $1',
                [employeeId]
            );

            if (result.rows.length === 0) {
                return res.status(404).json({
                    message: "ÏÇ¨Ïö©ÏûêÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
                });
            }

            user = result.rows[0];
            await setUserCache(employeeId, user);
        }

        // ÎπÑÎ∞ÄÎ≤àÌò∏Îäî Ï†úÏô∏ÌïòÍ≥† Î∞òÌôò
        const { password, ...userData } = user;

        res.json(userData);

    } catch (error) {
        console.error("Get user error:", error);
        res.status(500).json({
            message: "ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§."
        });
    } finally {
        client.release();
    }
});

// 5. ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÏàòÏ†ï
app.put("/api/user/:employeeId", async (req, res) => {
    const client = await pool.connect();

    try {
        const { employeeId } = req.params;
        const { name, email, phone, address } = req.body;

        await client.query('BEGIN');

        // DB ÏóÖÎç∞Ïù¥Ìä∏
        const result = await client.query(
            `UPDATE users 
             SET name = COALESCE($1, name),
                 email = COALESCE($2, email),
                 phone = COALESCE($3, phone),
                 address = COALESCE($4, address),
                 updated_at = NOW()
             WHERE employee_id = $5
             RETURNING *`,
            [name, email, phone, address, employeeId]
        );

        if (result.rows.length === 0) {
            await client.query('ROLLBACK');
            return res.status(404).json({
                message: "ÏÇ¨Ïö©ÏûêÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
            });
        }

        // Redis Ï∫êÏãú Î¨¥Ìö®Ìôî
        await invalidateUserCache(employeeId);

        await client.query('COMMIT');

        res.json({
            message: "ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥Í∞Ä ÏàòÏ†ïÎêòÏóàÏäµÎãàÎã§.",
            user: result.rows[0]
        });

    } catch (error) {
        await client.query('ROLLBACK');
        console.error("Update user error:", error);
        res.status(500).json({
            message: "ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÏàòÏ†ï Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§."
        });
    } finally {
        client.release();
    }
});

// ============================================
// Í∞úÎ∞úÏö©: DB Ï¥àÍ∏∞Ìôî Î∞è ÌÖåÏä§Ìä∏ Îç∞Ïù¥ÌÑ∞
// ============================================

// DB ÌÖåÏù¥Î∏î ÏÉùÏÑ±
app.post("/api/dev/init-db", async (req, res) => {
    const client = await pool.connect();

    try {
        await client.query(`
            CREATE TABLE IF NOT EXISTS users (
                id SERIAL PRIMARY KEY,
                employee_id VARCHAR(50) UNIQUE NOT NULL,
                password VARCHAR(255),
                name VARCHAR(100) NOT NULL,
                email VARCHAR(255),
                phone VARCHAR(20),
                address TEXT,
                kakao_id VARCHAR(100) UNIQUE,
                marketing_agreed BOOLEAN DEFAULT false,
                created_at TIMESTAMP DEFAULT NOW(),
                updated_at TIMESTAMP DEFAULT NOW()
            );

            CREATE INDEX IF NOT EXISTS idx_employee_id ON users(employee_id);
            CREATE INDEX IF NOT EXISTS idx_kakao_id ON users(kakao_id);
        `);

        res.json({
            message: "Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌÖåÏù¥Î∏îÏù¥ ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§."
        });

    } catch (error) {
        console.error("Init DB error:", error);
        res.status(500).json({
            message: "Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî Ïã§Ìå®",
            error: error.message
        });
    } finally {
        client.release();
    }
});

// ÌÖåÏä§Ìä∏ ÏÇ¨Ïö©Ïûê ÏÉùÏÑ±
app.post("/api/dev/create-test-user", async (req, res) => {
    const client = await pool.connect();

    try {
        await client.query('BEGIN');

        const testUser = {
            employeeId: "12345",
            password: "test1234",
            name: "ÌôçÍ∏∏Îèô",
            email: "hong@kpmg.com",
            phone: "010-1234-5678",
            address: "ÏÑúÏö∏ÌäπÎ≥ÑÏãú Í∞ïÎÇ®Íµ¨ ÌÖåÌó§ÎûÄÎ°ú 123"
        };

        const result = await client.query(
            `INSERT INTO users (employee_id, password, name, email, phone, address)
             VALUES ($1, $2, $3, $4, $5, $6)
             ON CONFLICT (employee_id) DO UPDATE 
             SET password = $2, name = $3, email = $4, phone = $5, address = $6
             RETURNING *`,
            [testUser.employeeId, testUser.password, testUser.name,
                testUser.email, testUser.phone, testUser.address]
        );

        // RedisÏóê Ï∫êÏã±
        await setUserCache(testUser.employeeId, result.rows[0]);

        await client.query('COMMIT');

        res.json({
            message: "ÌÖåÏä§Ìä∏ ÏÇ¨Ïö©Ïûê ÏÉùÏÑ± ÏôÑÎ£å",
            user: result.rows[0]
        });

    } catch (error) {
        await client.query('ROLLBACK');
        console.error("Create test user error:", error);
        res.status(500).json({
            message: "ÌÖåÏä§Ìä∏ ÏÇ¨Ïö©Ïûê ÏÉùÏÑ± Ïã§Ìå®",
            error: error.message
        });
    } finally {
        client.release();
    }
});

// Redis Ï∫êÏãú Ï¥àÍ∏∞Ìôî
app.post("/api/dev/clear-cache", async (req, res) => {
    try {
        await redis.flushDb();
        res.json({
            message: "Redis Ï∫êÏãúÍ∞Ä Ï¥àÍ∏∞ÌôîÎêòÏóàÏäµÎãàÎã§."
        });
    } catch (error) {
        console.error("Clear cache error:", error);
        res.status(500).json({
            message: "Ï∫êÏãú Ï¥àÍ∏∞Ìôî Ïã§Ìå®"
        });
    }
});

// ============================================
// ÏÑúÎ≤Ñ ÏãúÏûë
// ============================================
const PORT = 3000;
app.listen(PORT, async () => {
    console.log(`\nüöÄ Server running at http://localhost:${PORT}\n`);

    // DB Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
    console.log('üîå PostgreSQL Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ Ï§ë...');
    try {
        const result = await pool.query('SELECT NOW()');
        console.log('‚úÖ PostgreSQL Ïó∞Í≤∞ ÏÑ±Í≥µ');
        console.log('   ÏÑúÎ≤Ñ ÏãúÍ∞Ñ:', result.rows[0].now);
    } catch (error) {
        console.error('‚ùå PostgreSQL Ïó∞Í≤∞ Ïã§Ìå®');
        console.error('   ÏóêÎü¨ ÏΩîÎìú:', error.code);
        console.error('   ÏóêÎü¨ Î©îÏãúÏßÄ:', error.message);
        console.error('   ÏÉÅÏÑ∏ Ï†ïÎ≥¥:', {
            host: pool.options.host,
            port: pool.options.port,
            database: pool.options.database,
            user: pool.options.user,
        });
        console.error('   Ï†ÑÏ≤¥ ÏóêÎü¨:', error);
    }

    // Redis Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
    console.log('\nüîå Redis Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ Ï§ë...');
    try {
        await redis.ping();
        console.log('‚úÖ Redis Ïó∞Í≤∞ ÏÑ±Í≥µ');
    } catch (error) {
        console.error('‚ùå Redis Ïó∞Í≤∞ Ïã§Ìå®');
        console.error('   ÏóêÎü¨ Î©îÏãúÏßÄ:', error.message);
        console.error('   Ï†ÑÏ≤¥ ÏóêÎü¨:', error);
    }

    console.log(`\nüìù API Endpoints:`);
    console.log(`   POST /api/auth/login - ÏùºÎ∞ò Î°úÍ∑∏Ïù∏`);
    console.log(`   POST /api/auth/kakao - Ïπ¥Ïπ¥Ïò§ Î°úÍ∑∏Ïù∏`);
    console.log(`   POST /api/auth/signup - ÌöåÏõêÍ∞ÄÏûÖ`);
    console.log(`   GET  /api/user/:employeeId - ÏÇ¨Ïö©Ïûê Ï°∞Ìöå`);
    console.log(`   PUT  /api/user/:employeeId - ÏÇ¨Ïö©Ïûê ÏàòÏ†ï`);
    console.log(`\nüõ†Ô∏è  Dev Endpoints:`);
    console.log(`   POST /api/dev/init-db - DB ÌÖåÏù¥Î∏î ÏÉùÏÑ±`);
    console.log(`   POST /api/dev/create-test-user - ÌÖåÏä§Ìä∏ ÏÇ¨Ïö©Ïûê ÏÉùÏÑ±`);
    console.log(`   POST /api/dev/clear-cache - Redis Ï∫êÏãú Ï¥àÍ∏∞Ìôî`);
});